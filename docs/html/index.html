<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simulidar: simulidar</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">simulidar
   </div>
   <div id="projectbrief">Simulation d&#39;un robot cartographiant un environnement à l&#39;aide d&#39;un Lidar en C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Recherche','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">simulidar </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md0"></a>
Simulation de Navigation Robotique avec LiDAR</h1>
<p >Ce projet implémente une simulation robotique utilisant un <b>robot mobile équipé d'un LiDAR</b> pour explorer un environnement inconnu. Il utilise OpenCV pour visualiser l'environnement et la carte du robot en temps réel.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Membres du groupe</h2>
<ul>
<li>FERRIER Simon</li>
<li>LAMOULLER Clément</li>
<li>PARIZOT Luan</li>
</ul>
<h2><a class="anchor" id="autotoc_md2"></a>
Objectif du projet</h2>
<p >Le but est de simuler un robot mobile explorant un environnement inconnu en utilisant un LiDAR pour construire une carte. Le robot doit éviter les obstacles, explorer toutes les zones accessibles et naviguer efficacement.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Diagramme UML du projet</h2>
<p ><img src="images/simulidar_uml.svg" alt="Diagramme UML" style="pointer-events: none;" class="inline"/> </p>
<h2><a class="anchor" id="autotoc_md4"></a>
Documentation</h2>
<p >La documentation complète est hébergée sur GitHub Pages : <a href="https://cyclemnt.github.io/simulidar/">Accéder à la documentation</a></p>
<h2><a class="anchor" id="autotoc_md5"></a>
Fonctionnalités</h2>
<ul>
<li><b>Environnement généré aléatoirement</b> avec des obstacles de tailles variées.</li>
<li><b><a class="el" href="de/d78/classRobot.html" title="Représente le robot.">Robot</a> initialisé aléatoirement</b> sans conaissance de sa position.</li>
<li><b>Algorithme de <a href="https://lodev.org/cgtutor/raycasting.html">raycasting</a></b> pour les mesures LiDAR.</li>
<li><b>Exploration autonome</b> avec mise à jour de la carte à partir des données du LiDAR.<ul>
<li>Algorithme <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A*</a> pour la recherche de chemin.</li>
</ul>
</li>
<li><b>Visualisation en temps réel</b> :<ul>
<li>Vue 2D de l'environnement et de la carte du robot.</li>
<li>Vue 3D simplifiée utilisant le raycasting pour simuler la perception du robot. <br  />
</li>
</ul>
</li>
</ul>
<p ><em><b>Nous nous engageons à ce que le robot n'ait aucun accès direct ou indirect aux informations de l'environnement, à l'exception des données obtenues via le capteur <a class="el" href="d2/da5/classLidar.html" title="Représente le Lidar simulé.">Lidar</a>. Ainsi, toutes les décisions du robot sont basées uniquement sur les informations fournies par ce capteur.</b></em></p>
<h2><a class="anchor" id="autotoc_md6"></a>
Dépendances</h2>
<ul>
<li><b><a href="https://opencv.org/">OpenCV</a></b> : Pour les affichages graphiques.</li>
<li><b>CMake</b> : Pour la configuration et la construction du projet.</li>
<li><b>C++11</b> ou version ultérieure.</li>
</ul>
<h2><a class="anchor" id="autotoc_md7"></a>
Installation et Compilation</h2>
<p ><b>Cloner le dépôt</b> : </p><div class="fragment"><div class="line">git clone https://github.com/Cyclemnt/simulidar.git</div>
</div><!-- fragment --><p> <b>Compiler</b> : </p><div class="fragment"><div class="line">cd simulidar</div>
<div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake ..</div>
<div class="line">make</div>
<div class="line">./main</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Utilisation</h2>
<ol type="1">
<li>Une fois le programme lancé, la simulation démarre en plaçant le robot aléatoirement dans un environnement. <br  />
 Appuyez sur n'importe quelle touche pour commencer.</li>
<li>La simulation met à jour en temps réel l'état de l'environnement et la carte du robot.</li>
<li>Une fois que toutes les zones accessibles ont été explorées, la simulation s'arrête. <br  />
 Appuyez sur n'importe quelle touche pour fermer les fenêtres.</li>
</ol>
<h2><a class="anchor" id="autotoc_md9"></a>
Personalisation</h2>
<p >Modifiez les paramètres dans <a class="el" href="dd/de3/types_8hpp.html">types.hpp</a> pour personnaliser la simulation :</p>
<ul>
<li><b>ENV_WIDTH</b>, <b>ENV_HEIGHT</b> : Dimensions de l’environnement.</li>
<li><b>OBSTACLE_NUM</b>, <b>OBSTACLE_MAX_SIZE</b> : Nombre et taille des obstacles.</li>
<li><b>TIMESTEP</b> : Pas de temps entre les mises à jour.</li>
<li><b>LIDAR_MAX_RANGE</b>, <b>LIDAR_RAY_COUNT</b> : Portée et précision du <a class="el" href="d2/da5/classLidar.html" title="Représente le Lidar simulé.">Lidar</a>.</li>
<li><b>SPEED</b>, <b>ANG_V</b> : Vitesse du robot.</li>
</ul>
<h2><a class="anchor" id="autotoc_md10"></a>
Exemple visuel</h2>
<p ><img src="images/demo_simulidar.gif" alt="Demo" class="inline"/> </p>
<hr  />
<h1><a class="anchor" id="autotoc_md12"></a>
Démarche de réflexion</h1>
<h2><a class="anchor" id="autotoc_md13"></a>
Problème à résoudre</h2>
<p >L'objectif de ce projet est de simuler un robot autonome capable d'explorer son environnement et de reconstruire une carte en temps réel. Le robot, équipé d'un capteur de distance de type <a class="el" href="d2/da5/classLidar.html" title="Représente le Lidar simulé.">Lidar</a> et d'un système de localisation idéal, doit détecter et cartographier les obstacles présents dans l’environnement.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Démarche adoptée</h2>
<h3><a class="anchor" id="autotoc_md15"></a>
Étape 1 : Analyse des besoins</h3>
<p >Pour atteindre ces objectifs, nous avons identifié les éléments nécessaires : <br  />
</p><ol type="1">
<li>Un modèle d'environnement contenant des obstacles de tailles et positions aléatoires. <br  />
</li>
<li>Un capteur <a class="el" href="d2/da5/classLidar.html" title="Représente le Lidar simulé.">Lidar</a> simulé capable de détecter les obstacles tout autour du robot. <br  />
</li>
<li>Un mécanisme de mise à jour de la carte, permettant au robot de marquer les zones explorées et non explorées. <br  />
</li>
<li>Un algorithme de navigation robuste pour planifier les déplacements du robot. <br  />
</li>
<li>Un moyen de visualisation en temps réel. <br  />
</li>
</ol>
<h3><a class="anchor" id="autotoc_md16"></a>
Étape 2 : Modélisation du problème</h3>
<p >L'environnement est représenté comme une grille d'occupation 2D, où chaque cellule correspond à une portion de l'espace. Les obstacles sont définis comme des zones bloquées dans cette grille. Le robot utilise un <a class="el" href="d2/da5/classLidar.html" title="Représente le Lidar simulé.">Lidar</a> simulé pour mesurer une distance jusqu'à un éventuel obstacle. Les déplacements sont modélisés comme des transitions d'un point (x, y) à un autre sur la grille. La navigation utilise une version simplifiée de l’algorithme A* pour trouver le chemin optimal.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md18"></a>
Explication de la solution</h2>
<h3><a class="anchor" id="autotoc_md19"></a>
Lidar simulé</h3>
<p >Le <a class="el" href="d2/da5/classLidar.html" title="Représente le Lidar simulé.">Lidar</a> simule un capteur de distance à 360 degrés qui permet au robot de détecter les obstacles dans son environnement en projetant des rayons (raycasting). Chaque rayon mesure la distance jusqu'à l'obstacle le plus proche dans sa direction, en utilisant un algorithme basé sur la méthode DDA (Digital Differential Analyzer).</p>
<h4><a class="anchor" id="autotoc_md20"></a>
Fonctionnement du Lidar</h4>
<ol type="1">
<li><b>Position initiale et orientation</b> : <br  />
<ul>
<li>Le capteur récupère la position absolue du robot dans l'environnement (<em>rayStartX</em>, <em>rayStartY</em>) et son orientation actuelle (<em>orientation</em>). <br  />
</li>
<li>Chaque rayon est défini par un ID (<em>rayID</em>), ce qui détermine son angle relatif par rapport à l'orientation du robot.</li>
</ul>
</li>
<li><p class="startli"><b>Calcul de l'angle du rayon</b> : <br  />
 L'angle d'un rayon est calculé par la formule : <br  />
</p>
<p class="startli"><em>rayAngle = orientation + (rayID - rayCount / 2) * (pi / 180)</em></p>
<p class="startli">Cela répartit les rayons uniformément autour du robot sur 360°.</p>
</li>
<li><p class="startli"><b>Définition de la direction</b> : <br  />
 Le rayon est représenté comme un vecteur directeur (<em>rayDirX</em>, <em>rayDirY</em>), calculé à partir de la fonction trigonométrique : <br  />
</p>
<p class="startli"><em>rayDirX = cos(rayAngle)</em>, <em>rayDirY = sin(rayAngle)</em></p>
</li>
<li><p class="startli"><b>Pas de progression</b> : <br  />
 Le rayon progresse à travers la grille de l'environnement en calculant les distances à la prochaine ligne verticale ou horizontale de la grille, en utilisant : <br  />
</p>
<p class="startli"><em>rayUnitStepSizeX = sqrt(1 + (rayDirY / rayDirX)^2)</em>, <em>rayUnitStepSizeY = sqrt(1 + (rayDirX / rayDirY)^2)</em></p>
</li>
<li><b>Avancée du rayon avec DDA</b> : <br  />
<ul>
<li>Le rayon avance dans la grille case par case, en alternant entre les lignes et colonnes selon les distances accumulées <em>rayLengthX</em> et <em>rayLengthY</em>. <br  />
</li>
<li>Pour chaque nouvelle case traversée, le programme vérifie si elle contient un obstacle.</li>
</ul>
</li>
<li><b>Détection d'obstacle ou dépassement de portée</b> : <br  />
<ul>
<li>Si une case contenant un obstacle <code>CellState::Wall</code> est détectée, le <a class="el" href="d2/da5/classLidar.html" title="Représente le Lidar simulé.">Lidar</a> retourne la distance accumulée. <br  />
</li>
<li>Si aucun obstacle n'est trouvé dans la portée maximale du <a class="el" href="d2/da5/classLidar.html" title="Représente le Lidar simulé.">Lidar</a> <em>30 m</em>, la fonction retourne <em>-1</em>.</li>
</ul>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md21"></a>
Cartographie</h3>
<p >La mise à jour de la carte se fait à chaque balayage des rayons du LiDAR. Avec la fonction <code>castRayAndMarkObstacle</code>, chaque cellule traversée par le rayon est marquée comme libre, et la cellule à la distance mesurée est marquée comme un mur. Si le rayon dépasse les limites actuelles de la carte, celle-ci est étendue dynamiquement.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
Choix de la destination</h3>
<p >Le robot choisit sa prochaine cible en cherchant la cellule inconnue la plus proche, adjacente à une cellule libre. La distance est calculée selon la distance de Manhattan, soit la somme des différences absolues des coordonnées x et y entre deux points. La cellule la plus proche devient la prochaine destination.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
Algorithme A*</h3>
<p >L'algorithme A* trouve le chemin optimal entre un point de départ et un objectif en utilisant une combinaison de coût réel et d'une estimation du coût restant (heuristique). L'heuristique utilisée ici est la distance de Manhattan, qui est la somme des distances absolues en x et en y entre le point actuel et l'objectif.</p>
<h4><a class="anchor" id="autotoc_md24"></a>
Fonctionnement de A*</h4>
<ol type="1">
<li>Initialisation</li>
</ol>
<ul>
<li><b>Carte</b> : La carte est une grille contenant des états (<code>CellState::Wall</code> pour les murs et des cellules libres pour les déplacements).</li>
<li><b>Coût <em>gScore</em></b> : Coût réel pour atteindre une cellule depuis le point de départ. <br  />
 Initialement, toutes les cellules ont un coût infini, sauf le point de départ <em>gScore(start) = 0</em>.</li>
<li><p class="startli"><b>Coût fScore</b> : Somme du coût réel <em>gScore</em> et d'une estimation heuristique <em>h(current, goal)</em> pour atteindre l'objectif. <br  />
 Pour le départ : <br  />
</p>
<p class="startli"><em>fScore(start) = h(start, goal) = |start.x - goal.x| + |start.y - goal.y|</em></p>
<p class="startli">(Distance de Manhattan, adaptée pour les mouvements sur une grille orthogonale.)</p>
</li>
<li><b>File de priorité</b> : Les nœuds à explorer sont organisés dans une file de priorité (<em>openQueue</em>), triée selon <em>fScore</em>.</li>
</ul>
<ol type="1">
<li>Recherche du chemin L'algorithme suit un processus itératif :</li>
</ol>
<ol type="1">
<li><b>Sélection du meilleur nœud</b> : <br  />
 Extraire de la file de priorité le nœud avec le coût <em>fScore</em> le plus faible.</li>
<li><b>Vérification de l'objectif</b> : <br  />
 Si ce nœud est l'objectif, reconstruire le chemin en remontant les parents via <em>cameFrom</em>.</li>
<li><b>Exploration des voisins</b> : <br  />
 Pour chaque voisin orthogonal du nœud actuel : <br  />
<ul>
<li>Ignorer les voisins hors limites ou occupant un mur.</li>
<li>Calculer un coût provisoire pour atteindre le voisin <em>gScore(current + 1)</em>.</li>
<li>Si le voisin est atteint avec un coût inférieur à un chemin précédent : <br  />
<ul>
<li>Mettre à jour <em>gScore(neighbor)</em> et <em>fScore(neighbor)</em>.</li>
<li>Ajouter le voisin à la file de priorité.</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr  />
<h2><a class="anchor" id="autotoc_md26"></a>
Déplacement du robot</h2>
<p >La fonction <code><a class="el" href="de/d78/classRobot.html#ac2707bcb99c2c0b55f4ca98a7077fcc0" title="Exécuter l&#39;instruction (s&#39;orienter et avancer).">Robot::executeInstruction()</a></code> est dédiée au déplacement incrémental du robot vers une position cible spécifiée. Elle décompose le mouvement en deux étapes : ajustement de l'orientation et déplacement en ligne droite.</p>
<ul>
<li><b>Orientation</b> : La fonction calcule l'angle nécessaire pour que le robot pointe dans la direction de la cible. Si l'orientation actuelle diffère de l'orientation cible, le robot ajuste son angle de rotation en tenant compte de sa vitesse angulaire maximale.</li>
<li><b>Avancement</b> : Une fois correctement orienté, le robot avance vers la cible à une vitesse constante. La distance parcourue est limitée par le produit de la vitesse de déplacement maximale et du pas de temps (<code>timeStep</code>).</li>
<li><b>Condition d'accomplissement</b> : La fonction vérifie si le robot a atteint la position cible en comparant ses coordonnées actuelles avec celles de la cible. Si c'est le cas, elle retourne true. Sinon, elle continue d'ajuster orientation et position dans les appels suivants.</li>
</ul>
<p >Cette méthode est appelée en boucle pour guider le robot pas à pas vers la cible, en s'assurant que chaque mouvement est précis et limité par les capacités physiques du robot.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md28"></a>
Orchestration des fonctions</h2>
<p >La méthode <code><a class="el" href="d1/d7b/classSimulation.html#ae5c367f87c0b5dc9740bc6d00e44e72c" title="Démarrer la simulation.">Simulation::run()</a></code> orchestre l'ensemble du processus d'exploration de l'environnement par le robot. Elle combine la collecte de données, la mise à jour de la carte, le calcul des trajets et l'exécution des mouvements dans une boucle principale.</p>
<ul>
<li><b>Lecture des capteurs</b> : À chaque itération, la simulation commence par lire les données des capteurs LiDAR du robot pour détecter les obstacles autour de lui.</li>
<li><b>Mise à jour de la carte</b> : Ces données sont utilisées pour mettre à jour la carte interne de l'environnement, en ajoutant ou en modifiant les cellules pour refléter les zones découvertes ou occupées.</li>
<li><b>Calcul de la cible et du chemin</b> : La simulation identifie le point inexploré le plus proche en utilisant <code>findNearestInterestPoint()</code>. Elle utilise ensuite l’algorithme A* pour calculer le chemin optimal reliant la position actuelle du robot à ce point cible.</li>
<li><b>Déplacement du robot</b> : Si un chemin est trouvé, la simulation décompose le trajet en instructions unitaires que le robot exécute pas à pas avec <code>executeInstruction()</code>. Pendant ces déplacements, la carte est mise à jour visuellement pour refléter les progrès.</li>
<li><b>Condition de fin</b> : Si aucun point inexploré n'est accessible, l'exploration est considérée comme terminée, affiche un message, et met fin à l'exécution.</li>
</ul>
<p >Cette fonction constitue le cœur de la simulation, en assurant une exploration systématique de l'environnement jusqu'à ce que toutes les zones soient découvertes ou qu'il soit impossible d'atteindre de nouvelles cibles.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Résultats</h2>
<h3><a class="anchor" id="autotoc_md30"></a>
Visualisations</h3>
<p  align="center">Les résultats incluent deux types de visualisations pour mieux comprendre le comportement du robot : <br  />
</p><ol type="1">
<li><b>Vue 2D de l’environnement et de la carte du robot</b> : <br  />
 </li>
</ol>
<p ><img src="images/environment_view.png" alt="Vue de l'environnement" class="inline"/><img src="images/robotmap_view.png" alt="Carte du robot" class="inline"/> </p>
<p >Cette vue montre la position du robot, les obstacles et sa carte de départ, qui est vide. <br  />
</p>
<ol type="1">
<li><b>Vue 3D simulée (Raycasting)</b> : <br  />
 </li>
</ol>
<p ><img src="images/raycasting_view.png" alt="Vue 3D Raycasting" class="inline"/> </p>
<p >Cette vue simule la perception du robot en projetant les lectures du <a class="el" href="d2/da5/classLidar.html" title="Représente le Lidar simulé.">Lidar</a> sur un plan 3D.</p>
<h3><a class="anchor" id="autotoc_md31"></a>
Performance</h3>
<p >Le robot explore entièrement les zones accessibles dans des environnements complexes. Les performances dépendent de la densité des obstacles et de la portée du <a class="el" href="d2/da5/classLidar.html" title="Représente le Lidar simulé.">Lidar</a>.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Conclusion</h2>
<p >Ce projet montre comment un robot autonome peut explorer un environnement inconnu en combinant planification de chemin, mise à jour de carte en temps réel et perception par capteur. Les résultats démontrent l'efficacité de cette approche dans des scénarios variés. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
